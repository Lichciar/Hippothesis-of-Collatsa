#!/usr/bin/env python3

# --------------- комментарий 72 символа -------------------------------
# ----------------------- код 79 символов -------------------------------------

# Задание:
"""
Реализация гипотезы Лотара Коллатса:
(саракузская проблема)
1. Берём любое натуральное число.
2. Если оно чётное, то делим его на 2.
3. Если оно нечётное, то умножаем на 3 и прибавляем 1.
4. Над полученным результатом проводим операции №2 или №3.

Утверждение: какое бы число не взяли, получим 1.

Начало: 01 декабря 2021 г. 17:45.
Обновлена: 31 мая 2024 г. 23:51."""

# Версия скрипта.
version = '0.1.4'

# Планирование разработки:

# Исправлено в ver. 0.1:
"""
1. Черновик скрипта."""

# Исправлено в ver. 0.1.1:
"""
1. Закоментирована (читать ОТКЛЮЧЕНА) запись результата работы
   программы в файл, потому что очень быстро засоряется файловая
   система. Очень долгое открытие папки и удаление файлов. К тому
   же для системы NTFS есть физическое ограничение на количество
   файлов в папке и на диске в целом: 4 294 967 295. Данным скриптом
   мы повесим систему. Файлы в целом маленькие, и возможно имеет
   смысл записывать их по несколько штук (1 миллион результатов в
   файл).
2. Добавил временно вывод текущего числа и время его расчёта."""

# Исправлено в ver. 0.1.2:
"""
1. Результат работы отображать при помощи черепашки - плохо!!!."""

# Исправлено в ver. 0.1.3 от 13 сентября 2023 г.:
"""
1. Отображение результат при помощи черепашки временно убрано.
2. Сохранение результатов работы при помощи SQLite3.
3. Модернизация функции load_current_number для работы
   с базой данных.
4. Модернизация функции save_current_number для работы
   с базой данных.
5. Модернизация функции save_result для работы
   с базой данных.
6. Полностью избавились от использования json-файлов."""

# Исправлено в ver. 0.1.4 от 31 мая 2024 г.:
"""
1. Создаём класс Cache, который будет собирать данные о работе,
   например 100 элементов, и загружать их единовременно. Опытным путём
   выяснено, что для SSD данная эффективность теряется после 10 000.
   Больше ставить нет смысла.
2. В функцию load_current_number добавлено открытие БД и её закрытие.
3. Функцию save_current_number по факту перенесена в класс Cache,
   функцию ldid.
4. Корректировка комментарием в коде для его визуально сжатия: задание,
   информацию о версиях и исправлениях взял в блоки комментариев.
5. Скорость работы скрипта стала "заоблочная" в виду того, что
   уменьшилось время работы с ПЗУ (чем больше кэш, тем меньше
   обращений к ПЗУ и больше ОЗУ нужно для хранения результата).
6. Как итог: за 5 мин, 1 400 000 чисел посчитано, 1,78Гб ПЗУ."""

# План работ на ver. 0.X:
"""
1. Нечётные версии добавляют функционал, чётные убираю баги.
3. Рассмотреть возможность многопоточности, например, 4 потока:
   1 поток - 1, 5, 9..., 2 поток - 2, 6, 10..., 3 поток - 3, 7, 11...
4. Добавить в базу данных контрольную сумму для результата: hashlib.
5. Заменить формат хранения результата работы скрипта. На данный момент
   результат формируется в строку "8 -> 4 -> 2 -> 1", что равно 16-и
   символам, а могло быть "8, 4, 2, 1" 4-ем целым числам. Экономия
   места для хранения на лицо.
6. Добавить функцию запуска скрипта без записи в БД.
5. При запуске проверять контрольную сумму последних 100 вычислений."""

Подключение модулей.
import settings # Файл настройки.
import cache    # Класс описывающий кэш.
import sqlite3  # Модуль работы с БД SQLite3.
from time import strftime, localtime, time, gmtime  # Модуль времени.

# Описание функций.
def load_current_number():
    """Чтение текущего натурального числа из базы данных (далее БД)."""

    con = sqlite3.connect(settings.DB_FILENAME) # Подкл-ся к БД.
    cur = con.cursor() # Создаём курсор для работы с БД.

    # Чтение текущего значения из базы данных.
    query = 'SELECT natural_number FROM CN_tables WHERE id = 1'
    current_number = cur.execute(query).fetchone()

    con.close() # Закрываем соединение с БД.

    return current_number[0] # Возвращаем результат.

def operations(number):
    """ Математические операциии согласно гипотезе."""

    number = int(number)
    # Если чётное "/2", если нечётное "3х+1".
    if (number % 2) == 1:
        number = 3 * number + 1
    else:
        number = int(number / 2)

    return number # Возвращаем результат.

# Warning
def chain_write(chain, number):
    """ Запись натурального числа в цепочку."""

    # Пузырьковый сдвиг вверх.
    # (W) Может можно как-то переделать? Посмотреть...
    chain[0] = chain[1]
    chain[1] = chain[2]
    chain[2] = chain[3]
    chain[3] = chain[4]
    chain[4] = chain[5]
    chain[5] = number

    return chain # Возвращаем результат.

def chain_test(chain):
    """ Проверка гипотезы."""

    # Если есть цикл, то надо переходить к следующему числу.
    if chain[0] == chain[3] and chain[1] == chain[4] and chain[2] == chain[5]:
        return True

    return False # Если цикл не обнаружем, продолжаем.

# Основное тело скрипта.
if __name__ == '__main__':

    # Выводим приветствие программы.
    print('Hippothesis of Collatsa v.' + version)

    con = sqlite3.connect(settings.DB_FILENAME) # Подкл-ся к БД.
    cur = con.cursor() # Создаём курсор для работы с БД.

    # Создаём таблицу CN_tables для хранения текущего числа.
    try:
        query = 'CREATE TABLE CN_tables(id, natural_number)'
        cur.execute(query)
        # Пустая таблица создаётся со значение 1.
        query = 'INSERT INTO CN_tables VALUES (1, 1)'
        cur.execute(query)
        con.commit() # Записываем в БД.
    # Если таблицы созданы, то читаем из них.
    except:
        pass # Ошибки пока не обрабатываем.

    # Создаём таблицу Result_tables для хранения текущего числа.
    try:
        query = ('CREATE TABLE Result_tables(id integer primary key ' +
            'autoincrement, natural_number, chain_results, time)')
        cur.execute(query)
        con.commit() # Записываем в БД.
    except:
        pass # Ошибки пока не обрабатываем.

    con.close() # Закрываем соединение с БД.

    # Получаем натуральное число из базы данных.
    natural_number = int(load_current_number())
    data = cache.Cache(10000) # Создаём кэш, экземпляр класса Cache.

    # Запускаем основной цикл перебора натуральных чисел.
    while True:
        start_script = time() # Засекаем время начала вычисления.
        chain_results = '' # Инициализируем цепочку для результата.
        current_number = natural_number

        # Инициализируем цепочку для проверки нулём т.к.
        # он не участвует в математических операциях.
        chain_loop = [0, 0, 0, 0, 0, 0]

        # Производим математические операции над натуральным числом,
        # пока не получим результат.
        while True:

            # Записываем в цепь натуральное число.
            chain_loop = chain_write(chain_loop, current_number)

            # Записываем в результат операции.
            chain_results += str(current_number)
            chain_results += ' -> '

            # Проверяем на наличие цикла.
            if chain_test(chain_loop):
                break # Если закономерность найдена, выходим из цикла.

            # Проверяем: 3х+1 или х/2?
            current_number = operations(current_number)

        # Один повтор с конца строки обрезаем.
        chain_temp = (' -> ' + str(chain_loop[3]) + ' -> ' +
            str(chain_loop[4]) + ' -> ' + str(chain_loop[5]) + ' -> ')
        chain_results = chain_results[:-len(chain_temp)]

        data.add({'natural_number': natural_number,
                  'chain_results': chain_results,
                  'time': time() - start_script})

        # Увеличиваем натуральное число на единицу.
        natural_number += 1
