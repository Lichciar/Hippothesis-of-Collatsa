#!/usr/bin/env python3

# --------------- комментарий 72 символа -------------------------------
# ----------------------- код 79 символов -------------------------------------

"""Задание:

Реализация гипотезы Лотара Коллатса:
(саракузская проблема)
1. Берём любое натуральное число.
2. Если оно чётное, то делим его на 2.
3. Если оно нечётное, то умножаем на 3 и прибавляем 1.
4. Над полученным результатом проводим операции №2 или №3.

Утверждение: какое бы число не взяли, получим 1.

Начало: 01 декабря 2021 г. 17:45.
Обновлена: 11 марта 2024 г. 15:59.

"""

# Версия скрипта.  
version = '0.1.3'

# Планирование разработки:

# Исправлено в ver.0.1:
# -----------------------
# 1. Черновик скрипта.

# Исправлено в ver.0.1.1:
# -----------------------
# 1. Закоментирована (читать ОТКЛЮЧЕНА) запись результата работы
#    программы в файл, потому что очень быстро засоряется файловая
#    система. Очень долгое открытие папки и удаление файлов. К тому
#    же для системы NTFS есть физическое ограничение на количество
#    файлов в папке и на диске в целом: 4 294 967 295. Данным скриптом
#    мы повесим систему. Файлы в целом маленькие, и возможно имеет
#    смысл записывать их по несколько штук (1 миллион результатов в
#    файл).
# 2. Добавил временно вывод текущего числа и время его расчёта.

# Исправлено в ver.0.1.2:
# ----------------------
# 1. Результат работы отображать при помощи черепашки - плохо!!!.

# Исправлено в ver.0.1.3 от 13 сентября 2023 г.:
# ----------------------
# 1. Отображение результат при помощи черепашки временно убрано.
# 2. Сохранение результатов работы при помощи SQLite3.
# 3. Модернизация функции load_current_number для работы
#    с базой данных.
# 4. Модернизация функции save_current_number для работы
#    с базой данных.
# 5. Модернизация функции save_result для работы
#    с базой данных.
# 6. Полностью избавились от использования json-файлов.

# Исправлено в ver.0.1.4:
# ----------------------
# 1. Создаём класс Cache, который будет собирать данные о работе, например 100 шт., и загружать их единовременно.

# План работ на ver.0.X:
# ----------------------
# 0. Нечётные версии добавляют функционал, чётные убираю баги.
# 1. Сделать КЕШ для записей: запись каждого результата в базу данных
#    сильно нагружает HDD и процессор. Закрывает доспуп к базе данных.
# 2. Рассмотреть возможность многопоточности, например, 4 потока:
#    1 поток - 1, 5, 9..., 2 поток - 2, 6, 10..., 3 поток - 3, 7, 11...
# 3. Добавить в базу данных контрольную сумму для результата: hashlib.
# 4. При запуске проверять контрольную сумму последних 100 вычислений.

# Подключаем модуль SQLite3.
import sqlite3

# Подключаем модуль времени.
from time import strftime, localtime, time, gmtime

# Описание классов.
class Cache:
    """ Класс описывающий кэш с данными работы скрипта."""

    def __init__ (self):
        """ Конструктор класса."""

        # Натуральное число.
        self.natural_number = 1
        # Цепочка решения.
        self.chain_results = ""
        # Время вополнения рассчёта.
        self.w = 0


# Описание функций.
def save_result(number, chain, time):
    """Сохраняем результат работы скрипта. """

    # Сохраняем данные в базу данных.
    query = ("INSERT INTO Result_tables VALUES (NULL, " + str(number) + 
        ", \"" + str(chain) + "\", " + str(time) + ")")
    cur.execute(query)

    # Применяем изменения в базу данных.
    con.commit()

def load_current_number():
    """Чтение текущего натурального числа из базы данных. """

    # Чтение текущего значения из базы данных.
    query = "SELECT number FROM CN_tables WHERE id = 1"
    current_number = cur.execute(query).fetchone()
    
    # Возвращаем результат.
    return current_number[0]

def save_current_number(number):
    """Запись следующее натуральное число в базу данных. """

    # Запись текущего числа в базу данных.
    query = "UPDATE CN_tables SET number = " + str(number) + " WHERE id = 1"
    cur.execute(query)
    # Применяем изменения в базу данных.
    con.commit()

def operations(number):
    """ Математические операциии согласно гипотезе."""

    number = int(number)
    # Если чётное "/2", если нечётное "3х+1".
    if (number % 2) == 1:
        number = 3 * number + 1
    else:
        number = int(number / 2)

    # Возвращаем результат.
    return number

def chain_write(chain, number):
    """ Запись натурального числа в цепочку."""

    # Пузырьковый сдвиг вверх.
    # (W) Может можно как-то переделать? Посмотреть...
    chain[0] = chain[1]
    chain[1] = chain[2]
    chain[2] = chain[3]
    chain[3] = chain[4]
    chain[4] = chain[5]
    chain[5] = number

    # Возвращаем результат.
    return chain

def chain_test(chain):
    """ Проверка гипотезы."""

    # Если есть цикл, то надо переходить к следующему числу.
    if chain[0] == chain[3] and chain[1] == chain[4] and chain[2] == chain[5]:
        return True

    # Если цикл не обнаружем, продолжаем.
    return False

# Основное тело скрипта.
if __name__ == '__main__':

    # Выводим приветствие программы.
    print('Hippothesis of Collatsa v.' + version)

    # Наименование базы данных SQLite3.
    db_filename = 'hoc_database.db'

    # Подключаемся к базе данных.
    con = sqlite3.connect(db_filename)
    # Создаём курсор для работы с базой данных.
    cur = con.cursor()

    # Создаём таблицу CN_tables для хранения текущего числа.
    try:
        query = "CREATE TABLE CN_tables(id, number)"
        cur.execute(query)
        # Пустая таблица создаётся со значение 1.
        query = "INSERT INTO CN_tables VALUES (1, 1)"
        cur.execute(query)
        # Записываем с базу данных.
        con.commit()
    # Если таблицы созданы, то читаем из них.
    except:
        # Ошибки пока не обрабатываем.
        pass

    # Создаём таблицу Result_tables для хранения текущего числа.
    try:
        query = ("CREATE TABLE Result_tables(id integer primary key " +
            "autoincrement, number, result, time)")
        cur.execute(query)
        # Записываем с базу данных.
        con.commit()
    except:
        # Ошибки пока не обрабатываем.
        pass

    # Закрываем соединение с базой данных.
    con.close()

    # Запускаем основной цикл перебора натуральных чисел.
    while True:

        # Подключаемся к базе данных.
        con = sqlite3.connect(db_filename)
        # Создаём курсор для работы с базой данных.
        cur = con.cursor()

        # Засекаем время начала вычисления.
        start_script = time()

        # Получаем натуральное число из базы данных.
        natural_number = int(load_current_number())

        # Инициализируем цепочку для результата.
        chain_results = ''

        # Инициализируем цепочку для проверки нулём т.к.
        # он не участвует в математических операциях.
        chain_loop = [0, 0, 0, 0, 0, 0]

        # Производим математические операции над натуральным числом,
        # пока не получим результат.
        while True:

            # Записываем в цепь натуральное число.
            chain_loop = chain_write(chain_loop, natural_number)

            # Записываем в результат операции.
            chain_results += str(natural_number)
            chain_results += ' -> '

            # Проверяем на наличие цикла.
            if chain_test(chain_loop):
                # Если закономерность найдена, выходим из цикла.
                break

            # Проверяем: 3х+1 или х/2?
            natural_number = operations(natural_number)

        # Получаем натуральное число из файла.
        natural_number = int(load_current_number())

        # Один повтор с конца строки обрезаем.
        chain_temp = (' -> ' + str(chain_loop[3]) + ' -> ' +
            str(chain_loop[4]) + ' -> ' + str(chain_loop[5]) + ' -> ')
        chain_results = chain_results[:-len(chain_temp)]

        # Сохраняем результат в базу данных.
        # Временно отключено до решения проблеммы.
        save_result(natural_number, chain_results, (time() - start_script))
        
        # Увеличиваем натуральное число на единицу.
        natural_number += 1

        # Записываем натуральное число в базу данных.
        save_current_number(natural_number)

        # Закрываем соединение с базой данных.
        con.close()